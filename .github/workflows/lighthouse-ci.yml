name: Lighthouse CI

on:
  pull_request:
    branches: [main]
    paths:
      - 'frontend/**'
      - '.github/workflows/lighthouse-ci.yml'

jobs:
  lighthouse:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./frontend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli@0.14.x
          lhci autorun
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Lighthouse results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lighthouse-results
          path: frontend/.lighthouseci
          retention-days: 30

      - name: Comment PR with results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Read Lighthouse results
            const resultsPath = path.join(process.cwd(), 'frontend', '.lighthouseci');

            // Parse manifest.json to get latest results
            let performanceScore = null;
            let metrics = {};
            let hasRegression = false;
            let regressionDetails = [];

            try {
              const manifestPath = path.join(resultsPath, 'manifest.json');
              if (fs.existsSync(manifestPath)) {
                const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
                if (manifest.length > 0) {
                  const latestRun = manifest[manifest.length - 1];
                  const reportPath = path.join(resultsPath, latestRun.jsonPath);
                  const report = JSON.parse(fs.readFileSync(reportPath, 'utf8'));

                  performanceScore = Math.round(report.categories.performance.score * 100);

                  // Extract key metrics
                  metrics.lcp = Math.round(report.audits['largest-contentful-paint'].numericValue);
                  metrics.cls = report.audits['cumulative-layout-shift'].numericValue.toFixed(3);
                  metrics.tbt = Math.round(report.audits['total-blocking-time'].numericValue);
                  metrics.fcp = Math.round(report.audits['first-contentful-paint'].numericValue);

                  // Check for regressions (performance drop > 5 points or metric threshold violations)
                  const thresholds = {
                    performance: 90,
                    lcp: 2500,
                    cls: 0.1,
                    tbt: 200,
                    fcp: 1800
                  };

                  if (performanceScore < thresholds.performance) {
                    const drop = thresholds.performance - performanceScore;
                    if (drop > 5) {
                      hasRegression = true;
                      regressionDetails.push(`‚ö†Ô∏è **Performance Score**: ${performanceScore} (dropped ${drop} points from threshold)`);
                    }
                  }

                  if (metrics.lcp > thresholds.lcp) {
                    hasRegression = true;
                    regressionDetails.push(`‚ö†Ô∏è **LCP**: ${metrics.lcp}ms (exceeds ${thresholds.lcp}ms threshold)`);
                  }

                  if (parseFloat(metrics.cls) > thresholds.cls) {
                    hasRegression = true;
                    regressionDetails.push(`‚ö†Ô∏è **CLS**: ${metrics.cls} (exceeds ${thresholds.cls} threshold)`);
                  }

                  if (metrics.tbt > thresholds.tbt) {
                    hasRegression = true;
                    regressionDetails.push(`‚ö†Ô∏è **TBT**: ${metrics.tbt}ms (exceeds ${thresholds.tbt}ms threshold)`);
                  }
                }
              }
            } catch (error) {
              console.error('Error parsing Lighthouse results:', error);
            }

            let comment = '## üî¶ Lighthouse CI Results\n\n';

            // Add regression alert if detected
            if (hasRegression) {
              comment += '### ‚ö†Ô∏è Performance Regression Detected\n\n';
              comment += regressionDetails.join('\n') + '\n\n';
            }

            // Add current metrics
            if (performanceScore !== null) {
              const scoreEmoji = performanceScore >= 90 ? '‚úÖ' : performanceScore >= 50 ? '‚ö†Ô∏è' : '‚ùå';
              comment += `### Current Performance Metrics\n\n`;
              comment += `${scoreEmoji} **Performance Score**: ${performanceScore}/100\n\n`;
              comment += `**Core Web Vitals:**\n`;
              comment += `- LCP: ${metrics.lcp}ms ${metrics.lcp <= 2500 ? '‚úÖ' : '‚ùå'}\n`;
              comment += `- CLS: ${metrics.cls} ${parseFloat(metrics.cls) <= 0.1 ? '‚úÖ' : '‚ùå'}\n`;
              comment += `- TBT: ${metrics.tbt}ms ${metrics.tbt <= 200 ? '‚úÖ' : '‚ùå'}\n`;
              comment += `- FCP: ${metrics.fcp}ms ${metrics.fcp <= 1800 ? '‚úÖ' : '‚ùå'}\n\n`;
            }

            comment += '### Performance Thresholds\n';
            comment += '- ‚úÖ Performance Score: ‚â•90\n';
            comment += '- ‚úÖ LCP (Largest Contentful Paint): <2.5s\n';
            comment += '- ‚úÖ CLS (Cumulative Layout Shift): <0.1\n';
            comment += '- ‚úÖ TBT (Total Blocking Time): <200ms\n';
            comment += '- ‚úÖ FCP (First Contentful Paint): <1.8s\n\n';
            comment += '[View detailed Lighthouse reports in artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})\n';

            // Add historical tracking notice
            comment += '\n---\n';
            comment += 'üìä **Historical Tracking**: Results are uploaded to temporary public storage for trend analysis.\n';

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
